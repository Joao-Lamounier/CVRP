# import random
#
#
# class GeneticAlgorithm:
#
#     def __init__(self, graph, mutation_rate=0.05, population_size=50, num_generations=10000):
#         self.graph = graph
#         self.objetive_function = 0.0
#         self.routes = []
#         self.mutation_rate = mutation_rate
#         self.population_size = population_size
#         self.num_generations = num_generations
#         self.elitism_rate = 0.15
#
#     def create_individual(self):  # Precisa mudar... Totalmente Aleatório
#         clients = list(range(1, self.graph.dimension))
#         random.shuffle(clients)
#         return clients
#
#     def decode_individual(self, individual):
#         routes, current_route, current_capacity = [], [], 0.0
#
#         for client in individual:
#             demand = self.graph.demands[client]
#             if current_capacity + demand > self.graph.capacity:
#                 routes.append(current_route)
#                 current_route, current_capacity = [], 0
#
#             current_route.append(client)
#             current_capacity += demand
#
#         if current_route:
#             routes.append(current_route)
#
#         return routes
#
#     def calculate_fitness(self, individual):
#         routes = self.decode_individual(individual)
#         total_distance = 0.0
#
#         for route in routes:
#             route_distance = 0.0
#             previous = self.graph.depot
#
#             for client in route:
#                 route_distance += self.graph.graph[previous][client]
#                 previous = client
#
#             route_distance += self.graph.graph[previous][self.graph.depot]
#             total_distance += route_distance
#
#         # Penalização para soluções com mais veículos do que o permitido
#         if len(routes) > self.graph.vehicles:
#             total_distance += 1e6 * (len(routes) - self.graph.vehicles)
#
#
#         return -total_distance
#
#     def crossover(self, parent_1, parent_2):
#         cut = random.randint(1, len(parent_1) - 1)
#         child = parent_1[:cut] + [c for c in parent_2 if c not in parent_1[:cut]]
#         return child
#
#     def mutate(self, individual):
#         if random.random() < self.mutation_rate:
#             idx1, idx2 = random.sample(range(len(individual)), 2)
#             individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
#
#     def genetic_algorithm(self):
#         # Inicialização da população
#         population = [self.create_individual() for _ in range(self.population_size)]
#         fitness_scores = []
#
#         for generation in range(self.num_generations):
#             # Avaliação da população
#             fitness_scores = [(self.calculate_fitness(ind), ind) for ind in population]
#
#             # Ordenação da população por aptidão
#             fitness_scores.sort(reverse=True)
#
#             # Elitismo
#             num_elite = int(self.elitism_rate * self.population_size)
#             new_population = population[:num_elite]
#
#             population = [ind for _, ind in fitness_scores[:self.population_size // 2]]
#
#             # Geração da nova população
#             while len(new_population) < self.population_size:
#                 parent_1, parent_2 = random.sample(population, 2)
#                 child = self.crossover(parent_1, parent_2)
#                 self.mutate(child)
#                 new_population.append(child)
#
#             # Melhor solução da geração
#             # best_fitness, best_individual = fitness_scores[0]
#             # print(f"Geração {generation + 1}: Melhor Aptidão = {-best_fitness}")
#
#             # Nova população
#             population = new_population
#
#         # Melhor indivíduo
#         best_fitness, best_individual = fitness_scores[0]
#         self.objetive_function = -best_fitness
#         self.routes = self.decode_individual(best_individual)




# def crossover(self, parent_1, parent_2):
    #     # Passo 1: Inicializar a estrutura do filho
    #     child = [-1] * len(parent_1)
    #
    #     # Passo 2: Selecionar dois pontos de corte aleatórios
    #     cut1, cut2 = sorted(random.sample(range(len(parent_1)), 2))
    #
    #     # Passo 3: Copiar o segmento entre os pontos de corte de um dos pais para o filho
    #     child[cut1:cut2 + 1] = parent_1[cut1:cut2 + 1]
    #
    #     # Passo 4: Preencher o restante do filho com os elementos do outro pai, garantindo que não haja repetição
    #     current_pos = 0
    #     for i in range(len(parent_2)):
    #         # Encontrar o próximo elemento de parent_2 que não está no segmento já copiado
    #         while parent_2[i] in child:
    #             i += 1
    #             if i >= len(parent_2):
    #                 break
    #
    #         if i < len(parent_2):
    #             # Encontrar a próxima posição livre no filho
    #             while child[current_pos] != -1:
    #                 current_pos += 1
    #             child[current_pos] = parent_2[i]
    #
    #     return child


    def percentual_elementos_iguais(self, lista):
        if not lista:
            return 0.0

        # Converte listas internas em tuplas para torná-las "hashable" (imutáveis)
        lista_convertida = [tuple(x) if isinstance(x, list) else x for x in lista]

        counter = Counter(lista_convertida)  # Conta a frequência de cada elemento
        max_count = max(counter.values())  # Frequência máxima
        percentual = (max_count / len(lista)) * 100  # Calcula o percentual
        return percentual

                # Nova população
            # print(f'\nGeração: {generation + 1} Percentual Iguais: {self.percentual_elementos_iguais(new_population)}')


    def roulette_wheel_selection(self, fitness_scores):
    #     total_fitness = sum(fitness for fitness, _ in fitness_scores)
    #     print(total_fitness)
    #     pick = random.uniform(0, total_fitness)
    #     current = 0
    #     for fitness, individual in fitness_scores:
    #         current += fitness
    #         if current > pick:
    #             return individual
    #     return fitness_scores[-1][1]  # Retorna o último se algo der errado



            total_fitness = sum(fitness for fitness, _ in fitness_scores)
            relative_fitness = [f / total_fitness for f, _ in fitness_scores]
            cumulative_probability = [sum(relative_fitness[:i + 1]) for i in range(len(relative_fitness))]


            parent_1 = self.roulette_wheel_selection(population, cumulative_probability)
                parent_2 = self.roulette_wheel_selection(population, cumulative_probability)


        def roulette_wheel_selection(self, population, cumulative_probability):

        rand = random.random()
        for i, cp in enumerate(cumulative_probability):
            if rand <= cp:
                return population[i]